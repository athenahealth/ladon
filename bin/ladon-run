#!/usr/bin/env ruby

require 'pry'
require 'ladon'

# FIXME: eventually we should model Ladon in Ladon and use ModelAutomation here
class LadonAutomationRunner < Ladon::Automator::Automation
  ARGV_FLAG = :argv
  RIDICULOUS_BANNER =
    " _           _
| | __ _  __| | ___  _ __            _ __ _   _ _ __  _ __   ___ _ __
| |/ _` |/ _` |/ _ \\| '_ \\   _____  | '__| | | | '_ \\| '_ \\ / _ \\ '__|
| | (_| | (_| | (_) | | | | |_____| | |  | |_| | | | | | | |  __/ |
|_|\\__,_|\\__,_|\\___/|_| |_|         |_|   \\__,_|_| |_|_| |_|\\___|_|   ".freeze

  def setup
    argv_given = flags.get(ARGV_FLAG, default_to: nil)
    halting_assert('ARGV flag must be provided') do
      argv_given.is_a?(Array)
    end

    @options = nil # TODO: this may be delete-able
    halting_assert('Options provided must be valid') do
      @options = _parse_options(flags: argv_given)
      _validate_options?
    end

    halting_assert('Must be able to load a file at the specified path') do
      _load_automation_source
    end

    @target_automation_class = _select_automation_class
  end

  def execute
    _print_separator_line
    puts RIDICULOUS_BANNER
    _print_separator_line

    puts "\nStarting: #{@target_automation_class.name}"
    @target_automation = @target_automation_class.spawn(flags: @options.flags)

    @target_automation_class.all_phases.each_with_index do |phase_name, idx|
      _go_interactive if @options.interactive_before.include?(phase_name)

      print "Beginning phase: #{phase_name}..."
      @target_automation.run(to_index: idx) # this is the interesting line
      puts 'complete!'

      _go_interactive if @options.interactive_post.include?(phase_name)
    end
    puts "\nExecution complete"
  end

  def teardown
    _go_interactive if @options.nil? || @options.review

    puts "Result: #{result.status}"
  end

  # If there was a failure in setup, don't run execute.
  def skip_reason(phase)
    return "Failure detected in #{SETUP_PHASE}" if phase == EXECUTE_PHASE && !@result.success?
    super
  end

  private

  def _go_interactive
    puts ''
    _print_separator_line('-')
    puts "\tStarting interactive mode\n"

    binding.pry

    puts "\n\tInteractive mode exited, continuing..."
    _print_separator_line('-')
    puts ''
  end

  def _parse_options(flags: [])
    vals = Struct.new(:automation_path,
                      :automation_class_name,
                      :interactive_before,
                      :interactive_post,
                      :review,
                      :flags).new
    OptionParser.new do |opts|
      opts.banner = 'Usage: ladon-run [options]'

      opts.on('-a PATH',
              '--automation PATH',
              String,
              '[REQUIRED] Path to the automation script to be executed') do |val|
        vals.automation_path = val
      end

      opts.on('-s NAME',
              '--automation_class NAME',
              String,
              'Name of the Automation class to run.') do |val|
        vals.automation_class_name = val
      end

      opts.on('-b PHASE_LIST',
              '--interactive_before PHASE_LIST',
              String,
              'Comma-separated list of phases to enter interactive mode BEFORE running') do |val|
        vals.interactive_before = val.split(',').map { |phase| phase.strip.to_sym }
      end

      opts.on('-p PHASE_LIST',
              '--interactive_post PHASE_LIST',
              String,
              'Comma-separated list of phases to enter interactive mode AFTER running.') do |val|
        vals.interactive_post = val.split(',').map { |phase| phase.strip.to_sym }
      end

      opts.on('-f FLAGS',
              '--flags FLAGS',
              String,
              'Comma-separated list of name:value pairs') do |val|
        # HACK: won't work with flags that have commas in them
        vals.flags = Hash[val.split(',').map { |el| el.split(':', 2) }]
      end

      opts.on('-r', '--review', 'Pause after automation completes') do
        vals.review = true
      end

      opts.on('-h', '--help', 'Prints this help message') do
        puts opts
        exit
      end
    end.parse!(flags)

    vals
  end

  # returns true if the options are valid.
  def _validate_options?
    raise StandardError, 'Automation not specified!' unless @options.automation_path
    @options.interactive_post = [] unless @options.interactive_post.is_a?(Array)
    @options.interactive_before = [] unless @options.interactive_before.is_a?(Array)
    @options.flags = {} unless @options.flags.is_a?(Hash)
    true
  end

  def _load_automation_source
    require_relative File.expand_path(@options.automation_path, Dir.pwd) # load that path
  end

  def _select_automation_class
    # Attempt to load the specified class, if provided
    return Object.const_get(@options.automation_class_name) if @options.automation_class_name

    # Detect all Automation subclasses
    detected_automations = ObjectSpace.each_object(Ladon::Automator::Automation.singleton_class)

    # Filter to only those Automation subclasses that are marked executable
    executable_automations = detected_automations.select { |cls| cls.respond_to?(:abstract?) && !cls.abstract? }

    # Select a single executable Automation subclass to run
    raise StandardError, 'No non-abstract Automation subclasses detected! Exiting...' if executable_automations.empty?
    return executable_automations[0] if executable_automations.size == 1

    _interactive_class_select(executable_automations)
  end

  def _interactive_class_select(class_options)
    puts "\nPlease select the Automation you wish to run by entering one of the following numbers:"
    class_options.each_with_index { |cls, idx| puts "\t#{idx + 1}. #{cls.name}" }
    begin
      idx = gets.to_i
      raise StandardError unless idx > 0 && idx < class_options.size
      return class_options[idx]
    rescue
      puts 'Nope. Try again.'
      retry
    end
  end

  def _print_separator_line(sep = '*')
    puts sep.to_s * 80
  end
end

flags = Hash[LadonAutomationRunner::ARGV_FLAG, ARGV]
runner = LadonAutomationRunner.spawn(flags: Ladon::Flags.new(in_hash: flags))
runner.run

puts 'ladon-run complete!'
